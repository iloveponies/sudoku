(get 2 [1 2 2 3])
(get  [1 2 2 3] 2)
(get  [1 2 2 3] 3)
(get  [1 2 2 3] 1)
(get  [1 2 2 3] 0)
(board [[5 3 0 0 7 0 0 0 0]
        [6 0 0 1 9 5 0 0 0]
        [0 9 8 0 0 0 0 6 0]
        [8 0 0 0 6 0 0 0 3]
        [4 0 0 8 0 3 0 0 1]
        [7 0 0 0 2 0 0 0 6]
        [0 6 0 0 0 0 2 8 0]
        [0 0 0 4 1 9 0 0 5]
        [0 0 0 0 8 0 0 7 9]])
(def board identity)
(board [[5 3 0 0 7 0 0 0 0]
        [6 0 0 1 9 5 0 0 0]
        [0 9 8 0 0 0 0 6 0]
        [8 0 0 0 6 0 0 0 3]
        [4 0 0 8 0 3 0 0 1]
        [7 0 0 0 2 0 0 0 6]
        [0 6 0 0 0 0 2 8 0]
        [0 0 0 4 1 9 0 0 5]
        [0 0 0 0 8 0 0 7 9]])
board
(board)
(get board 2)
     (defn value-at [board coord]
  (get-in board coord))
(defn has-value? [board coord]
  (not (= (value-at board coord) 0)))
(value-at board [0 0])
(def board [[5 3 0 0 7 0 0 0 0]
        [6 0 0 1 9 5 0 0 0]
        [0 9 8 0 0 0 0 6 0]
        [8 0 0 0 6 0 0 0 3]
        [4 0 0 8 0 3 0 0 1]
        [7 0 0 0 2 0 0 0 6]
        [0 6 0 0 0 0 2 8 0]
        [0 0 0 4 1 9 0 0 5]
        [0 0 0 0 8 0 0 7 9]])
(value-at board [1 1])
(value-at board [0 1])
(get board 1)
(def all-values #{1 2 3 4 5 6 7 8 9})
(set (get board 1))
(map (fn [x] (get x 0)) board)
(set(map (fn [x] (get x 0)) board))
(defn coord-pairs [coords]
  (for [row coords
        col coords]
    [row col]))
(coord-pairs [0 1])
(coord-pairs [0 1 2])
(defn coord-pairs [coords]
  (for [row coords
        col coords]
    [row col]))
(defn col-values [board coord]
  (set ( map (fn [x] (get board (second coord))) board)))
(col-values boad [ 0 0])
(col-values board [ 0 0])
board
(map (fn [x] (get x 0)) board)
(defn col-values [board coord]
  (set (map (fn [x] (get x (second coord))) board)))
(col-values board [0 1])
(col-values board [1 0 ])
(doc mod)
(mod 5 3)
(mod 2 3)
(mod 4 3)
(- 4 (mod 4 3))
(- 3 (mod 3 3))
(defn tblock-values-helper
        (fn [x y] ([(- x (mod x 3)) (- y (mod y 3))]))
)
(defn tblock-values-helper
        [x y] ([(- x (mod x 3)) (- y (mod y 3))])
)
(tblock-values-helper [2 1])
(tblock-values-helper 2 1)
((fn [x y] ([(- x (mod x 3)) (- y (mode y 3))])) [1 2])
(fn [x y] ([(- x (mod x 3)) (- y (mode y 3))])) [1 2]
((fn [x y] ([(- x (mod x 3)) (- y (mod y 3))])) [1 2])
((fn [x y] ([x y])) [1 2])
((fn [x y] ([x y])) 1 2)
(fn [x y] ([x y])) 1 2
(fn [x y] (vector x y)) 1 2
((fn [x y] (vector x y)) 1 2)
((fn [x y] (vector (- x (mod x 3)) y)) 1 2)
((fn [x y] (vector (- x (mod x 3)) (- y (mod y 3))) 1 2)
)
((fn [x y] (vector (- x (mod x 3)) (- y (mod y 3)))) 1 2)
(defn block-values [board coord]
  (let [corner-pos
;        (fn [x y] ([(- x (mod x 3)) (- y (mod y 3))]))]
    ((fn [x y] (vector (- x (mod x 3)) (- y (mod y 3)))) coord)]
  corner-pos))
(block-values [1 2])
(defn block-values [board coord]
  (let [corner-pos
;        (fn [x y] ([(- x (mod x 3)) (- y (mod y 3))]))]
    ((fn [c] (vector (- (first c) (mod (first c) 3)) (- (second c) (mod (second c) 3)))) coord)]
  corner-pos))
(block-values [1 2])
(block-values board [1 2])
(defn block-values [board coord]
  (let [corner-pos
;        (fn [x y] ([(- x (mod x 3)) (- y (mod y 3))]))]
                                        ;    ((fn [c] (vector (- (first c) (mod (first c) 3)) (- (second c) (mod (second c) 3)))) coord)]
           ((fn [x y] (vector (- x (mod x 3)) (- y (mod y 3)))) coord)]
  corner-pos))
(block-values board [1 2])
(defn block-values [board coord]
  (let [corner-pos
        ((fn [c] (vector (- (first c) (mod (first c) 3)) (- (second c) (mod (second c) 3)))) coord)]
    (set (for [row '((first corner-pos) (inc (first corner-pos)) (+ 2 (first corner-pos)))
          col '((second corner-pos) (inc (second corner-pos)) (+ 2 (second corner-pos)))]
      (value-at [row col])))
    )) 
(block-values board [0 0])
(defn block-values [board coord]
  (let [corner-pos
        ((fn [c] (vector (- (first c) (mod (first c) 3)) (- (second c) (mod (second c) 3)))) coord)]
    (for [row '((first corner-pos) (inc (first corner-pos)) (+ 2 (first corner-pos)))
          col '((second corner-pos) (inc (second corner-pos)) (+ 2 (second corner-pos)))]
      (value-at [row col]))
    )) 
(block-values board [1 2])
(defn block-values [board coord]
  (let [corner-pos
        ((fn [c] (vector (- (first c) (mod (first c) 3)) (- (second c) (mod (second c) 3)))) coord)]
    (for [row '((first corner-pos) (inc (first corner-pos)) (+ 2 (first corner-pos)))
          col '((second corner-pos) (inc (second corner-pos)) (+ 2 (second corner-pos)))]
       [row col])
    ))
(block-values board [0 0])
(defn block-values [board coord]
  (let [corner-pos
        ((fn [c] (vector (- (first c) (mod (first c) 3)) (- (second c) (mod (second c) 3)))) coord)]
    (for [row (list (first corner-pos) (inc (first corner-pos)) (+ 2 (first corner-pos)))
          col (list (second corner-pos) (inc (second corner-pos)) (+ 2 (second corner-pos)))]
       [row col])
    ))
(block-values board [1 1])
(defn block-values [board coord]
  (let [corner-pos
        ((fn [c] (vector (- (first c) (mod (first c) 3)) (- (second c) (mod (second c) 3)))) coord)]
    (for [row (list (first corner-pos) (inc (first corner-pos)) (+ 2 (first corner-pos)))
          col (list (second corner-pos) (inc (second corner-pos)) (+ 2 (second corner-pos)))]
       (value-at [row col]))
    ))
(block-values board [ 1 2])
(block-values board [1 1])
(defn block-values [board coord]
  (let [corner-pos
        ((fn [c] (vector (- (first c) (mod (first c) 3)) (- (second c) (mod (second c) 3)))) coord)]
    (for [row (list (first corner-pos) (inc (first corner-pos)) (+ 2 (first corner-pos)))
          col (list (second corner-pos) (inc (second corner-pos)) (+ 2 (second corner-pos)))]
       (value-at board [row col]))
    )) 
(block-values board [1 1])
(defn block-values [board coord]
  (let [corner-pos
        ((fn [c] (vector (- (first c) (mod (first c) 3)) (- (second c) (mod (second c) 3)))) coord)]
    (set (for [row (list (first corner-pos) (inc (first corner-pos)) (+ 2 (first corner-pos)))
          col (list (second corner-pos) (inc (second corner-pos)) (+ 2 (second corner-pos)))]
       (value-at board [row col])))
    )) 
(block-values board [1 1])
(block-values board [1 2])
(block-values board [1 5])
(def all-values #{1 2 3 4 5 6 7 8 9})
(def board identity)
(def sudoku-board
  (board [[5 3 0 0 7 0 0 0 0]
          [6 0 0 1 9 5 0 0 0]
          [0 9 8 0 0 0 0 6 0]
          [8 0 0 0 6 0 0 0 3]
          [4 0 0 8 0 3 0 0 1]
          [7 0 0 0 2 0 0 0 6]
          [0 6 0 0 0 0 2 8 0]
          [0 0 0 4 1 9 0 0 5]
          [0 0 0 0 8 0 0 7 9]]))
(count sudoku-board)
(first sudoku-board)
(contains? (first sudoku-board) 0)
(reduce concat sudoku-board)
(contains? (reduce concat sudoku-board) 0)
(def sudoku-board
  (board [[5 3 0 0 7 0 0 0 0]
          [6 0 0 1 9 5 0 0 0]
          [0 9 8 0 0 0 0 6 0]
          [8 0 0 0 6 0 0 0 3]
          [4 0 0 8 0 3 0 0 1]
          [7 0 0 0 2 0 0 0 6]
          [0 6 0 0 0 0 2 8 0]
          [0 0 0 4 1 9 0 0 5]
          [0 0 0 0 8 0 0 7 9]]))
(defn filled? [board]
  (let [all-nums (reduce concat board)]
    (not (contains? all-nums 0))))
(filled? sudoku-board)
(def t2 (reduce concat sudoku-board))
t2
(set t2)
Contains? (set t2) 0)
(Contains? (set t2) 0)
(contains? (set t2) 0)
(defn filled? [board]
  (let [all-nums (reduce concat board)]
    (not (contains? (set all-nums) 0))))
(filled? sudoku-board)
(map set sudoku-board)
(doc range)
(range 1 9)
(map (fn [x] (get x 1)) sudoku-board)
(map (fn [x] (get x 0)) sudoku-board)
(set (map (fn [x] (get x 0)) sudoku-board))
(defn cols [board]
  (map (fn [col] (set (map (fn [row] (get row col)) board))) (range 0 8)))
(cols sudoku-board)
(defn cols [board]
  (map (fn [col] (set (map (fn [row] (get row col)) board))) (range 0 8)))
(cols sudoku-board)
(rows sudoku-board)
(defn rows [board]
  (map set board))
(rows sudoku-board)
(defn cols [board]
  (map (set (fn [col] (map (fn [row] (get row col)) board))) (range 0 8)))
(cols sudoku-board)
(defn cols [board]
  (map (fn [col] (set (map (fn [row] (get row col)) board))) (range 0 8)))
(cols sudoku-board
)
(count (cols sudoku-board))
(count (range 0 8))
(count (range 0 9))
(ns sudoku
  (:require [clojure.set :as set]))
(def board identity)
(def all-values #{1 2 3 4 5 6 7 8 9})
(defn value-at [board coord]
  (get-in board coord))
(defn has-value? [board coord]
  (not (= (value-at board coord) 0)))
(defn row-values [board coord]
  (set (get board (first coord))))
(defn col-values [board coord]
  (set (map (fn [x] (get x (second coord))) board)))
(defn coord-pairs [coords]
  (for [row coords
        col coords]
    [row col]))
(defn block-values [board coord]
  (let [corner-pos
        ((fn [c] (vector (- (first c) (mod (first c) 3)) (- (second c) (mod (second c) 3)))) coord)]
    (set (for [row (list (first corner-pos) (inc (first corner-pos)) (+ 2 (first corner-pos)))
          col (list (second corner-pos) (inc (second corner-pos)) (+ 2 (second corner-pos)))]
       (value-at board [row col])))
    ))  
(defn valid-values-for [board coord]
  ( if (has-value? board coord)
   #{}
   (set/difference all-values (set/union (row-values board coord) (col-values board coord ) (block-values board coord)))
   ))
(defn filled? [board]
  (let [all-nums (reduce concat board)]
    (not (contains? (set all-nums) 0))))
(defn rows [board]
  (map set board))
(defn valid-rows? [board]
  nil)
(defn cols [board]
  (map (fn [col] (set (map (fn [row] (get row col)) board))) (range 0 9)))
(defn valid-cols? [board]
  nil)
(defn blocks [board]
;  (let [blocks-helper
;        (fn [x y] (set (map (value-at board [x y])
;                        ])
)
(defn valid-blocks? [board]
  nil)
(defn valid-solution? [board]
  nil)
(defn set-value-at [board coord new-value]
  nil)
(defn find-empty-point [board]
  nil)
(defn solve [board]
  nil)
(block-values board [ 1 1])
(def sudoku-board
  (board [[5 3 0 0 7 0 0 0 0]
          [6 0 0 1 9 5 0 0 0]
          [0 9 8 0 0 0 0 6 0]
          [8 0 0 0 6 0 0 0 3]
          [4 0 0 8 0 3 0 0 1]
          [7 0 0 0 2 0 0 0 6]
          [0 6 0 0 0 0 2 8 0]
          [0 0 0 4 1 9 0 0 5]
          [0 0 0 0 8 0 0 7 9]]))
(block-values sudoku-board)
(block-values sudoku-board [ 0 0]) 
(block-values sudoku-board [ 0 3]) 
(zip [0 3 6] [0 3 6])
(doc zip)
(doc zipper)
(doc zipmap)
(doc map)
(zipmap [0 3 6] [0 3 6])
(zipmap [0 3 6] [ 6 3 0])
(zipmap [0 3 6 3 6 0 6 0 3] [ 6 3 0])
(for num [0 3 6]
map (fn [x] ([x 0] [x 3] [x 6])))
(for num [0 3 6]
map (fn [x] ([x 0] [x 3] [x 6])) num)
(defn blocks [board]
  (for [row [0 3 6]
        col [0 3 6]]
    (block-values board [row col])))
(blocks sudoku-board)
(= #{1 2} #{1 2})
(= #{1 2} #{1 2 3})
(defn valid-rows? [board]
  (map (fn [x] (= all-values x)) (rows board)))
(valid-rows? sudoku-board)
(contains? (set (valid-rows? sudoku-board)) false)
(doc value-at?)
(doc value-at)
(doc let)
(value-at sudoku-board 1 1)
(value-at sudoku-board [1 1])
(value-at sudoku-board [1 0])
(defn find-empty-point [board]
  (first (filter (fn [x y] ((= 0 (value-at board [x y]))
                            (for [row (range 0 9)
                                  col (range 0 9)]
                              [row col])))))
  )
(find-empty-point sudoku-board)
 (for [row (range 0 9)
                                  col (range 0 9)]
                              [row col])
(find-empty-point sudoku-board)
(def mapped
 (for [row (range 0 9)
                                  col (range 0 9)]
                              [row col])
)
(first mapped)
(doc filter
)
(Doc filter)
(filter (fn [x] (= 0 (value-at sudoku-board x))) mapped)
(value-at sudoku-board [0 2])
(filter (fn [x] (= 0 (value-at sudoku-board x))) mapped)
(first (filter (fn [x] (= 0 (value-at sudoku-board x))) mapped))
(defn find-empty-point [board]
  (first (filter (fn [coord] (= 0 (value-at board coord)))
                            (for [row (range 0 9)
                                  col (range 0 9)]
                              [row col]))))
(find-empty-point sudoku-board)
