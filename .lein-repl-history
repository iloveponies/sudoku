(get 2 [1 2 2 3])
(get  [1 2 2 3] 2)
(get  [1 2 2 3] 3)
(get  [1 2 2 3] 1)
(get  [1 2 2 3] 0)
(board [[5 3 0 0 7 0 0 0 0]
        [6 0 0 1 9 5 0 0 0]
        [0 9 8 0 0 0 0 6 0]
        [8 0 0 0 6 0 0 0 3]
        [4 0 0 8 0 3 0 0 1]
        [7 0 0 0 2 0 0 0 6]
        [0 6 0 0 0 0 2 8 0]
        [0 0 0 4 1 9 0 0 5]
        [0 0 0 0 8 0 0 7 9]])
(def board identity)
(board [[5 3 0 0 7 0 0 0 0]
        [6 0 0 1 9 5 0 0 0]
        [0 9 8 0 0 0 0 6 0]
        [8 0 0 0 6 0 0 0 3]
        [4 0 0 8 0 3 0 0 1]
        [7 0 0 0 2 0 0 0 6]
        [0 6 0 0 0 0 2 8 0]
        [0 0 0 4 1 9 0 0 5]
        [0 0 0 0 8 0 0 7 9]])
board
(board)
(get board 2)
     (defn value-at [board coord]
  (get-in board coord))
(defn has-value? [board coord]
  (not (= (value-at board coord) 0)))
(value-at board [0 0])
(def board [[5 3 0 0 7 0 0 0 0]
        [6 0 0 1 9 5 0 0 0]
        [0 9 8 0 0 0 0 6 0]
        [8 0 0 0 6 0 0 0 3]
        [4 0 0 8 0 3 0 0 1]
        [7 0 0 0 2 0 0 0 6]
        [0 6 0 0 0 0 2 8 0]
        [0 0 0 4 1 9 0 0 5]
        [0 0 0 0 8 0 0 7 9]])
(value-at board [1 1])
(value-at board [0 1])
(get board 1)
(def all-values #{1 2 3 4 5 6 7 8 9})
(set (get board 1))
(map (fn [x] (get x 0)) board)
(set(map (fn [x] (get x 0)) board))
(defn coord-pairs [coords]
  (for [row coords
        col coords]
    [row col]))
(coord-pairs [0 1])
(coord-pairs [0 1 2])
(defn coord-pairs [coords]
  (for [row coords
        col coords]
    [row col]))
(defn col-values [board coord]
  (set ( map (fn [x] (get board (second coord))) board)))
(col-values boad [ 0 0])
(col-values board [ 0 0])
board
(map (fn [x] (get x 0)) board)
(defn col-values [board coord]
  (set (map (fn [x] (get x (second coord))) board)))
(col-values board [0 1])
(col-values board [1 0 ])
(doc mod)
(mod 5 3)
(mod 2 3)
(mod 4 3)
(- 4 (mod 4 3))
(- 3 (mod 3 3))
(defn tblock-values-helper
        (fn [x y] ([(- x (mod x 3)) (- y (mod y 3))]))
)
(defn tblock-values-helper
        [x y] ([(- x (mod x 3)) (- y (mod y 3))])
)
(tblock-values-helper [2 1])
(tblock-values-helper 2 1)
((fn [x y] ([(- x (mod x 3)) (- y (mode y 3))])) [1 2])
(fn [x y] ([(- x (mod x 3)) (- y (mode y 3))])) [1 2]
((fn [x y] ([(- x (mod x 3)) (- y (mod y 3))])) [1 2])
((fn [x y] ([x y])) [1 2])
((fn [x y] ([x y])) 1 2)
(fn [x y] ([x y])) 1 2
(fn [x y] (vector x y)) 1 2
((fn [x y] (vector x y)) 1 2)
((fn [x y] (vector (- x (mod x 3)) y)) 1 2)
((fn [x y] (vector (- x (mod x 3)) (- y (mod y 3))) 1 2)
)
((fn [x y] (vector (- x (mod x 3)) (- y (mod y 3)))) 1 2)
(defn block-values [board coord]
  (let [corner-pos
;        (fn [x y] ([(- x (mod x 3)) (- y (mod y 3))]))]
    ((fn [x y] (vector (- x (mod x 3)) (- y (mod y 3)))) coord)]
  corner-pos))
(block-values [1 2])
(defn block-values [board coord]
  (let [corner-pos
;        (fn [x y] ([(- x (mod x 3)) (- y (mod y 3))]))]
    ((fn [c] (vector (- (first c) (mod (first c) 3)) (- (second c) (mod (second c) 3)))) coord)]
  corner-pos))
(block-values [1 2])
(block-values board [1 2])
(defn block-values [board coord]
  (let [corner-pos
;        (fn [x y] ([(- x (mod x 3)) (- y (mod y 3))]))]
                                        ;    ((fn [c] (vector (- (first c) (mod (first c) 3)) (- (second c) (mod (second c) 3)))) coord)]
           ((fn [x y] (vector (- x (mod x 3)) (- y (mod y 3)))) coord)]
  corner-pos))
(block-values board [1 2])
(defn block-values [board coord]
  (let [corner-pos
        ((fn [c] (vector (- (first c) (mod (first c) 3)) (- (second c) (mod (second c) 3)))) coord)]
    (set (for [row '((first corner-pos) (inc (first corner-pos)) (+ 2 (first corner-pos)))
          col '((second corner-pos) (inc (second corner-pos)) (+ 2 (second corner-pos)))]
      (value-at [row col])))
    )) 
(block-values board [0 0])
(defn block-values [board coord]
  (let [corner-pos
        ((fn [c] (vector (- (first c) (mod (first c) 3)) (- (second c) (mod (second c) 3)))) coord)]
    (for [row '((first corner-pos) (inc (first corner-pos)) (+ 2 (first corner-pos)))
          col '((second corner-pos) (inc (second corner-pos)) (+ 2 (second corner-pos)))]
      (value-at [row col]))
    )) 
(block-values board [1 2])
(defn block-values [board coord]
  (let [corner-pos
        ((fn [c] (vector (- (first c) (mod (first c) 3)) (- (second c) (mod (second c) 3)))) coord)]
    (for [row '((first corner-pos) (inc (first corner-pos)) (+ 2 (first corner-pos)))
          col '((second corner-pos) (inc (second corner-pos)) (+ 2 (second corner-pos)))]
       [row col])
    ))
(block-values board [0 0])
(defn block-values [board coord]
  (let [corner-pos
        ((fn [c] (vector (- (first c) (mod (first c) 3)) (- (second c) (mod (second c) 3)))) coord)]
    (for [row (list (first corner-pos) (inc (first corner-pos)) (+ 2 (first corner-pos)))
          col (list (second corner-pos) (inc (second corner-pos)) (+ 2 (second corner-pos)))]
       [row col])
    ))
(block-values board [1 1])
(defn block-values [board coord]
  (let [corner-pos
        ((fn [c] (vector (- (first c) (mod (first c) 3)) (- (second c) (mod (second c) 3)))) coord)]
    (for [row (list (first corner-pos) (inc (first corner-pos)) (+ 2 (first corner-pos)))
          col (list (second corner-pos) (inc (second corner-pos)) (+ 2 (second corner-pos)))]
       (value-at [row col]))
    ))
(block-values board [ 1 2])
(block-values board [1 1])
(defn block-values [board coord]
  (let [corner-pos
        ((fn [c] (vector (- (first c) (mod (first c) 3)) (- (second c) (mod (second c) 3)))) coord)]
    (for [row (list (first corner-pos) (inc (first corner-pos)) (+ 2 (first corner-pos)))
          col (list (second corner-pos) (inc (second corner-pos)) (+ 2 (second corner-pos)))]
       (value-at board [row col]))
    )) 
(block-values board [1 1])
(defn block-values [board coord]
  (let [corner-pos
        ((fn [c] (vector (- (first c) (mod (first c) 3)) (- (second c) (mod (second c) 3)))) coord)]
    (set (for [row (list (first corner-pos) (inc (first corner-pos)) (+ 2 (first corner-pos)))
          col (list (second corner-pos) (inc (second corner-pos)) (+ 2 (second corner-pos)))]
       (value-at board [row col])))
    )) 
(block-values board [1 1])
(block-values board [1 2])
(block-values board [1 5])
(def all-values #{1 2 3 4 5 6 7 8 9})
(def board identity)
(def sudoku-board
  (board [[5 3 0 0 7 0 0 0 0]
          [6 0 0 1 9 5 0 0 0]
          [0 9 8 0 0 0 0 6 0]
          [8 0 0 0 6 0 0 0 3]
          [4 0 0 8 0 3 0 0 1]
          [7 0 0 0 2 0 0 0 6]
          [0 6 0 0 0 0 2 8 0]
          [0 0 0 4 1 9 0 0 5]
          [0 0 0 0 8 0 0 7 9]]))
(count sudoku-board)
(first sudoku-board)
(contains? (first sudoku-board) 0)
(reduce concat sudoku-board)
(contains? (reduce concat sudoku-board) 0)
(def sudoku-board
  (board [[5 3 0 0 7 0 0 0 0]
          [6 0 0 1 9 5 0 0 0]
          [0 9 8 0 0 0 0 6 0]
          [8 0 0 0 6 0 0 0 3]
          [4 0 0 8 0 3 0 0 1]
          [7 0 0 0 2 0 0 0 6]
          [0 6 0 0 0 0 2 8 0]
          [0 0 0 4 1 9 0 0 5]
          [0 0 0 0 8 0 0 7 9]]))
(defn filled? [board]
  (let [all-nums (reduce concat board)]
    (not (contains? all-nums 0))))
(filled? sudoku-board)
(def t2 (reduce concat sudoku-board))
t2
(set t2)
Contains? (set t2) 0)
(Contains? (set t2) 0)
(contains? (set t2) 0)
(defn filled? [board]
  (let [all-nums (reduce concat board)]
    (not (contains? (set all-nums) 0))))
(filled? sudoku-board)
(map set sudoku-board)
(doc range)
(range 1 9)
(map (fn [x] (get x 1)) sudoku-board)
(map (fn [x] (get x 0)) sudoku-board)
(set (map (fn [x] (get x 0)) sudoku-board))
(defn cols [board]
  (map (fn [col] (set (map (fn [row] (get row col)) board))) (range 0 8)))
(cols sudoku-board)
(defn cols [board]
  (map (fn [col] (set (map (fn [row] (get row col)) board))) (range 0 8)))
(cols sudoku-board)
(rows sudoku-board)
(defn rows [board]
  (map set board))
(rows sudoku-board)
(defn cols [board]
  (map (set (fn [col] (map (fn [row] (get row col)) board))) (range 0 8)))
(cols sudoku-board)
(defn cols [board]
  (map (fn [col] (set (map (fn [row] (get row col)) board))) (range 0 8)))
(cols sudoku-board
)
(count (cols sudoku-board))
(count (range 0 8))
(count (range 0 9))
